/**
 * 
 */
package social.indiv;

import java.awt.Color;
import java.util.ArrayList;
import java.util.HashSet;

import social.world.Bond;
import social.world.WorldSpace;
import uchicago.src.sim.gui.RoundRectNetworkItem;
import uchicago.src.sim.network.DefaultDrawableNode;
import uchicago.src.sim.network.Edge;

/**
 * @author samer
 * 
 */
public class SimpleIndiv extends DefaultDrawableNode {

	/*
	 * Constants
	 */

	// default: 20; 30
	private static final int MAX_DRAWABLE_BONDS = 15;

	/*
	 * Implementation attributes
	 */
	private static int IDNumber = 1;

	private WorldSpace wSpace;

	public SimpleIndiv() {
		// autogenerated ID (unique label for the node):
		super("i" + IDNumber, new RoundRectNetworkItem(0, 0));
		IDNumber++;
	}

	/**
	 * @return Returns the wSpace.
	 */
	public WorldSpace getWSpace() {
		return wSpace;
	}

	/**
	 * @param space
	 *            The wSpace to set.
	 */
	public void setWSpace(WorldSpace space) {
		wSpace = space;
	}

	public double distance(SimpleIndiv ind) {
		return wSpace.distance(this, ind);
	}

	// ****************************************************************
	// Node:
	// ****************************************************************

	@SuppressWarnings("unchecked")
	public void setColorOfEdge(AttributedIndiv ind, Color colorFromGrade) {
		HashSet<AttributedIndiv> hash = this.getEdgesFrom(ind);
		if (hash == null || hash.isEmpty())
			hash = this.getEdgesTo(ind);

		if (hash != null && !hash.isEmpty()) {
			Object[] edges = hash.toArray();
			// if there is no problem, "edges" contains just one element:
			if (edges.length > 0) {
				Bond bond = ((Bond) edges[0]);
				bond.setColor(colorFromGrade);
			}
		}
	}

	/**
	 * Makes an edge to the specified node and from the specifed node to
	 * thisJinGirNewNode if both nodes do not already have edges to each other
	 * and if adding the edge keeps their degrees less than maxFriends. The
	 * edges is displayed in the specified color.
	 */
	public void makeBondTo(SimpleIndiv node, String type, Color color) {
		if ((!hasEdgeTo(node)) && (!hasEdgeFrom(node))
				&& getOutDegree() < MAX_DRAWABLE_BONDS
				&& node.getOutDegree() < MAX_DRAWABLE_BONDS) {

			Edge edge = new Bond(this, node, color, type);
			addOutEdge(edge);
			node.addInEdge(edge);
		}
	}

	@SuppressWarnings("unchecked")
	public void removeAllBonds() {
		boolean hasOutEdges = this.getOutEdges() != null
				&& this.getOutEdges().size() != 0;
		boolean hasInEdges = this.getInEdges() != null
				&& this.getInEdges().size() != 0;
		if (hasOutEdges) {
			ArrayList<SimpleIndiv> outRelatives = getOutNodes();
			for (int i = 0; i < outRelatives.size(); i++) {
				SimpleIndiv ind = (SimpleIndiv) outRelatives.get(i);
				removeEdgesTo(ind);
				ind.removeEdgesFrom(this);
				removeEdgesFrom(ind);
				ind.removeEdgesTo(this);
			}
		}
		if (hasInEdges) {
			ArrayList<SimpleIndiv> inRelatives = getInNodes();
			for (int i = 0; i < inRelatives.size(); i++) {
				SimpleIndiv ind = (SimpleIndiv) inRelatives.get(i);
				removeEdgesTo(ind);
				ind.removeEdgesFrom(this);
				removeEdgesFrom(ind);
				ind.removeEdgesTo(this);
			}
		}
	}

}
